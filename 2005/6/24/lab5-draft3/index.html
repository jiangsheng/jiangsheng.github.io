<!doctype html><html><head><meta charset="UTF-8"<title>Lab5 Draft3</head><body><div id="msgcns!1BE894DEAF296E0A!190" class="bvMsg"><p>reference: <a href="http://homepages.ius.edu/jfdoyle/c335/Html/ProcInvoke.htm">http://homepages.ius.edu/jfdoyle/c335/Html/ProcInvoke.htm</a></p> <p>;=====================================================================<br />; lab5.asm - build a program that displays the Fibonacci numbers for a user defined input upper bound<br />; Author: Sheng_Jiang<br />; Course: COSC 2425<br />; Date: 6/23/05<br />;=====================================================================</p> <p>   .386<br />   option casemap:none<br />   <br />   INCLUDE Irvine32.inc</p> <p>   ; -----------------------------------------------------------------<br />   ; include files that have MASM format prototypes for function calls<br />   ; -----------------------------------------------------------------<br />   <br />   ; ------------------------------------------------<br />   ; Library files that have definitions for function<br />   ; exports and tested reliable prebuilt code.<br />   ; ------------------------------------------------<br />   includelib gdi32.lib<br />   includelib user32.lib<br />   includelib kernel32.lib<br />   includelib Irvine32.lib<br />   <br />       ;costants<br />   CR EQU 0Dh<br />   LF EQU 0Ah<br />   TABLEWIDTH EQU  11<br />   HBAR        EQU  196<br />   VBAR        EQU  179<br />   ULCORNER    EQU  218<br />   URCORNER    EQU  191<br />   MLBORDER EQU  195<br />   MRBORDER EQU  180<br />   LLCORNER    EQU  192<br />   LRCORNER    EQU  217<br />   FILLSPACE EQU  32<br />   .Data<br />   menuSelection BYTE 0<br />   menustring  BYTE &quot;Menu|I - Display program instructions|N - The user is to enter an integer number from 0 to 20|F - Display the first N Fibonacci numbers on the console|X - Quit the program&quot;<br />   menustringLen DWORD $-menustring<br />   menuDelimiter DWORD &quot;|&quot;<br />   IsExitSelected BYTE 0<br />   number   BYTE 0<br />   .CODE<br />   <br />;draw a table line with text and delimiters<br />DrawTableLine  PROC NEAR C,  <br /> tableWidth : DWORD, <br /> beginChar : BYTE, <br /> textBuffer:NEAR PTR BYTE,<br /> textLen :DWORD,<br /> fillChar:BYTE,<br /> endChar:BYTE<br /> LOCAL sum : DWORD<br /> push eax<br /> push ebx<br /> push ecx<br /> ; do nothing if TableWidth&lt;2<br /> cmp textLen,2<br /> jb DrawTableLineCleanup<br /> ;beginChar, the left border<br /> mov   al,byte ptr [ebp+24]<br /> call  WriteChar<br />DrawTableLineCleanup:<br /> pop  ecx<br /> push ebx<br /> pop  eax<br /> ret<br />DrawTableLine ENDP <br />   <br />   <br />   <br />   <br />   ;the text<br />   <br />   ;ebx=min(TableWidth-2,textlen);<br />   mov   ebx,[ebp+16]    ;ebx=textlen<br />   mov   eax,ebx<br />   add   eax,2      ;eax=textlen+2<br />   cmp   eax,ecx      ;textlen+2&lt;=TableWidth?<br />   jbe   DrawTableLinePrintText  ;yes, print it<br />   mov   ebx,ecx      ;otherwise cut the string to TableWidth-2 characters<br />   sub   ebx,2      ;ebx=TableWidth-2<br />DrawTableLinePrintText:<br />   ;if no text to print,jump to fill the whole line<br />   cmp   ebx,0<br />   je   DrawTableLineFillLine<br />   ; print the text part<br />   push  ebx<br />   mov   edx, [ebp+20]<br />   mov   ebx,eax<br />   call  WriteString<br />   pop   ebx<br />DrawTableLineFillLine:<br />   ;fill the rest of table line<br />   ;call (fillchar,TableWidth-2-ebx)<br />   mov   eax, [ebp+28]<br />   sub   eax, 2<br />   sub   eax, ebx<br />   <br />   push  ecx<br />   mov   ecx,eax<br />DrawTableLineFillLineLoop:<br />   mov   al, [ebp+12] <br />   call  WriteChar  <br />   loop  DrawTableLineFillLineLoop<br />   pop   ecx<br />   <br />   ;endChar, the right border<br />   mov   al,[ebp+8]<br />   call  WriteChar</p> <p>   ;change line<br />   mov   al,CR<br />   call  WriteChar<br />   mov   al,LF<br />   call  WriteChar</p> <p>DrawTableLineCleanup:<br />   pop  esi<br />   pop  edx<br />   pop  ecx <br />   pop  ebx <br />   pop  eax <br />   mov  esp,ebp<br />   pop  ebp<br />   ret<br />DrawTableLine ENDP</p> <p>;draw a table top line(using ASCII code)<br />;usage: <br />;push TableWidth<br />;call DrawTableTop   <br />;pop TableWidth<br />DrawTableTop PROC<br />   push  ebp<br />   mov   ebp , esp<br />   ;call DrawTableLine(TableWidth,ULCORNER,NULL,NULL,HBAR,URCORNER)<br />   push  [esp+8];TableWidth<br />   push  ULCORNER<br />   push  0;<br />   push  0;<br />   push  HBAR<br />   push  URCORNER<br />   call DrawTableLine<br />   add  esp,24<br />   mov  esp,ebp<br />   pop  ebp<br />   ret<br />DrawTableTop ENDP</p> <p>;draw a table buttom line(using ASCII code)<br />;usage:<br />;push TableWidth<br />;call DrawTableButtom   <br />;pop TableWidth<br />DrawTableButtom PROC<br />   push  ebp<br />   mov   ebp , esp<br />   ;call DrawTableLine(TableWidth,LLCORNER,NULL,NULL,HBAR,LRCORNER)<br />   push  [esp+8];TableWidth<br />   push  LLCORNER<br />   push  0;<br />   push  0;<br />   push  HBAR<br />   push  LRCORNER<br />   call DrawTableLine<br />   add  esp,24<br />   mov  esp,ebp<br />   pop  ebp<br />   ret<br />DrawTableButtom ENDP</p> <p>;draw a table middle line(using ASCII code)<br />;usage: <br />;push TableWidth<br />;call DrawTableMiddleLine   <br />;pop TableWidth</p> <p>DrawTableMiddleLine PROC<br />   push  ebp<br />   mov   ebp , esp<br />   ;call DrawTableLine(TableWidth,MLBORDER,NULL,NULL,FILLSPACE,MRBORDER)<br />   push  [esp+8];TableWidth<br />   push  MLBORDER<br />   push  0;<br />   push  0;<br />   push  FILLSPACE<br />   push  MRBORDER<br />   call DrawTableLine<br />   add  esp,24<br />   mov  esp,ebp<br />   pop  ebp<br />   ret<br />DrawTableMiddleLine ENDP</p> <p>;draw table lines and print text (using ASCII code)<br />;wrap to seperate lines if the text is too long, or delimiters were found in the text<br />;usage: <br />;push TableWidth<br />;push stringbuffer<br />;push stringlen<br />;push delimiter<br />;call DrawTableLineWithWrap<br />;pop delimiter<br />;pop stringlen  <br />;pop stringbuffer <br />;pop TableWidth</p> <p>DrawTableLineWithWrap PROC<br />   push  ebp<br />   mov   ebp , esp<br />   <br />   push  eax ; <br />   push  ebx ; <br />   push  ecx ; <br />   push  edx ;<br />   push  edi ; <br />   push  esi ; <br />   mov   ebx ,[ebp+8] ;delimiter<br />   mov   ecx ,[ebp+12] ;stringlen<br />   mov   edx ,[ebp+20] ;TableWidth<br />   mov   esi ,[ebp+16] ;stringbuffer<br />   <br />   ;DWORD curlinebase=esi;<br />   ;BOOL bTerminate=FALSE;<br />   ;BOOL bDelimiter;<br />   ;edi=esi;<br />   ;<br />   ;while(!bTerminate&amp;&amp;edi&lt;esi+ecx)<br />   ;&#123;<br />   ; if(edi==esi+ecx-1 /*end of buffer*/)&#123;bDelimiter=FALSE;bTerminate=TRUE;&#125;<br />   ; else if([edi]=='')&#123;bDelimiter=TRUE;bTerminate=TRUE;&#125;<br />   ; else if([edi]==ebx /*delimiter*/)<br />   ; &#123;<br />   ;  if(edi==curlinebase)&#123;edi++; curlinebase=edi;continue;&#125;//skip leading delimiters<br />   ;  else bDelimiter=TRUE;<br />   ; &#125;  <br />   ; else if(edi==curlinebase+TableWidth-3) /*wrap*/&#123;bDelimiter=FALSE;&#125;<br />   ; else &#123;edi++; continue;&#125;<br />   ; DrawTableLine(TableWidth,MLBORDER,curlinebase,bDelimiter?edi-curlinebase:edi-curlinebase+1,FILLSPACE,MRBORDER);<br />   ; edi++;<br />   ; curlinebase=edi;<br />   ;&#125;<br />   <br />   mov   edi ,esi<br />   ;allocate local vars<br />   sub   esp ,12<br />   ;DWORD&amp; curlinebase=*(ebp-36);6 pushed registers<br />   ;BOOL&amp; bTerminate=*(ebp-32)<br />   ;BOOL&amp; bDelimiter=*(ebp-28)<br />   mov  dword ptr [ebp-36],esi<br />   mov  dword ptr [ebp-32],0<br />DrawTableLineWithWrapLoop:<br />   ;if(bTerminate==TRUE) goto DrawTableLineWithWrapCleanup<br />   cmp  dword ptr [ebp-32],0<br />   jne  DrawTableLineWithWrapCleanup</p> <p>   ;if(edi&gt;=esi+ecx) goto DrawTableLineWithWrapCleanup<br />   mov  eax,esi<br />   add  eax,ecx<br />   cmp  edi,eax   <br />   jae  DrawTableLineWithWrapCleanup<br />   <br />   dec  eax<br />   ;if(edi==esi+ecx-1) goto DrawTableLineWithWrapEndOfBuffer<br />   cmp  edi,eax   <br />   je  DrawTableLineWithWrapEndOfBuffer<br />   <br />   ;if([edi]==0) goto DrawTableLineWithWrapNullTerminator<br />   cmp  byte ptr [edi],0<br />   je  DrawTableLineWithWrapNullTerminator<br />   <br />   ;if([edi]==ebx) goto DrawTableLineWithWrapDelimiter<br />   cmp  byte ptr [edi],bl<br />   je  DrawTableLineWithWrapDelimiter<br />   <br />   ;if(edi==curlinebase+TableWidth-3) goto DrawTableLineWithWrapLineWrap<br />   mov  eax,[ebp-36]<br />   add  eax,edx<br />   sub  eax,3<br />   cmp  edi,eax<br />   je  DrawTableLineWithWrapLineWrap<br />   inc  edi<br />   jmp  DrawTableLineWithWrapLoop<br />DrawTableLineWithWrapEndOfBuffer:<br />   ;bTerminate=TRUE,bDelimiter=FALSE;<br />   mov  dword ptr [ebp-32],1<br />   mov  dword ptr [ebp-28],0<br />   jmp  DrawTableLineWithWrapDrawLine<br />DrawTableLineWithWrapNullTerminator:<br />   ;bTerminate=TRUE,bDelimiter=TRUE;<br />   mov  dword ptr [ebp-32],1<br />   mov  dword ptr [ebp-28],1<br />   jmp  DrawTableLineWithWrapDrawLine<br />DrawTableLineWithWrapDelimiter:<br />   ; if([edi]==ebx /*delimiter*/)<br />   ; &#123;<br />   ;  if(edi==curlinebase)&#123;edi++; continue;&#125;//skip leading delimiters<br />   ;  else bDelimiter=TRUE;<br />   ; &#125;<br />   cmp  edi,[ebp-36]<br />   je  DrawTableLineWithWrapDelimiter2<br />   mov  dword ptr [ebp-28],1<br />   jmp  DrawTableLineWithWrapDrawLine<br />DrawTableLineWithWrapDelimiter2:<br />   inc  edi<br />   ; curlinebase=edi;<br />   mov  [ebp-36],edi<br />   jmp  DrawTableLineWithWrapLoop   <br />DrawTableLineWithWrapLineWrap:<br />   ;bDelimiter=FALSE;<br />   mov  dword ptr [ebp-28],0<br />   ;jmp  DrawTableLineWithWrapDrawLine<br />DrawTableLineWithWrapDrawLine:<br />   ; DrawTableLine(TableWidth,MLBORDER,curlinebase,bDelimiter?edi-curlinebase:edi-curlinebase+1,FILLSPACE,MRBORDER);<br />   push edx    ;TableWidth<br />   push MLBORDER  ;beginchar<br />   push [ebp-36]  ;stringbuffer<br />   ;eax=bDelimiter?edi-curlinebase:edi-curlinebase+1<br />   mov  eax,edi<br />   sub  eax,[ebp-36]<br />   cmp  dword ptr [ebp-28],0<br />   jne  DrawTableLineWithWrapDrawLine2<br />   add  eax,1<br />DrawTableLineWithWrapDrawLine2: <br />   push eax    ;bufferlen<br />   push FILLSPACE   ;fillchar<br />   push MRBORDER  ;endchar<br />   call DrawTableLine<br />   add  esp,24<br />   ; edi++;<br />   inc  edi<br />   ; curlinebase=edi;<br />   mov  [ebp-36],edi<br />   jmp  DrawTableLineWithWrapLoop<br />DrawTableLineWithWrapCleanup:<br />   add   esp ,12<br />   pop   esi<br />   pop   edi<br />   pop   edx<br />   pop   ecx<br />   pop   ebx<br />   pop   eax<br />   mov  esp,ebp<br />   pop  ebp<br />   ret<br />DrawTableLineWithWrap ENDP</p> <p><br />ShowMenu Proc<br />   push  ebp<br />   mov   ebp , esp<br />   <br />   push TABLEWIDTH<br />   call DrawTableTop<br />   ;add  esp,4<br />   <br />   ;push TABLEWIDTH<br />   push OFFSET menustring<br />   push menustringLen<br />   push menuDelimiter<br />   call DrawTableLineWithWrap<br />   sub  esp,12<br />   <br />   ;push TABLEWIDTH<br />   call DrawTableButtom<br />   add  esp,4<br />   <br />   mov  esp,ebp<br />   pop  ebp<br />   ret<br />ShowMenu EndP</p> <p>;invoke WriteFile,hOutPut,lpszText,sl,ADDR bWritten,NULL<br />main  PROC<br />   int  3<br />   <br />   call ShowMenu</p> <p>;text code of OutputChar<br />;   push VBAR<br />;   call OutputChar<br />;   add  esp,4</p> <p>;test code of  DrawTableLineWithWrap  <br />;   push TABLEWIDTH<br />;   push OFFSET menustring<br />;   push menustringLen<br />;   push menuDelimiter<br />;   call DrawTableLineWithWrap<br />;   sub  esp,12<br />  <br />   exit<br />main  ENDP<br />   END  main</p> <p>#=====================================================================<br /># lab5 - build a program that displays the Fibonacci numbers for a user defined input upper bound<br /># Author: Sheng_Jiang<br /># Course: COSC 2425<br /># Date: 6/21/05<br />#=====================================================================<br />PROJECT = Lab5<br />NAME = Sheng_Jiang<br />Date = 6/21/05<br />ROOTDRIVE       = C<br />VERSION         = V1</p> <p>SRCS   = <br />    $(PROJECT).asm<br />    makefile </p> <p>MASM32          = $(ROOTDRIVE):/masm32<br />ML              = $(MASM32)/bin/ml<br />LINK            = $(MASM32)/bin/link<br />Zip    = H:/mydoc/Tools/Bin/zip<br />DEBUG   = c:/masm32/debug/windbg<br />Irvine32  = H:/mydoc/MyProjct/COSC2425/Lib32</p> <p>MLFLAGS         = /I. /I $(MASM32)include /I $(MASM32)macros /I $(Irvine32) /Zi /Zd /Zf /c /Fl /coff /Cp<br />LINKFLAGS       = /subsystem:console /libpath:$(MASM32)lib /libpath:$(Irvine32) /debug <br />DEBUGFLAGS  = -QY -g -G -WF $(PROJECT).WEW</p> <p>all: $(PROJECT).exe</p> <p>$(PROJECT).obj: $(PROJECT).asm<br /> $(ML) $(MLFLAGS) $(PROJECT).asm</p> <p>$(PROJECT).exe: $(PROJECT).obj<br /> $(LINK) $(LINKFLAGS) $(PROJECT).obj</p> <p>clean:<br /> del $(PROJECT).exe *.obj *.lst *.map *.pdb *.ilk</p> <p>zip:    clean<br />  del $(NAME)_$(PROJECT)_$(VERSION).zip<br />        $(Zip) $(NAME)_$(PROJECT)_$(VERSION).zip $(SRCS)<br />debug: $(PROJECT).exe<br />  $(DEBUG) $(DEBUGFLAGS) $(PROJECT).exe</p> <p><br /> </p></div></body></html>