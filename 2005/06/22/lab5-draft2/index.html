<!doctype html><html><head><meta charset="UTF-8"<title>Lab5 Draft2</head><body><div id="msgcns!1BE894DEAF296E0A!189" class="bvMsg"><font size="2"> <p>;=====================================================================</p> <p>; lab5.asm - build a program that displays the Fibonacci numbers for a user defined input upper bound</p> <p>; Author: Sheng_Jiang</p> <p>; Course: COSC 2425</p> <p>; Date: 6/21/05</p> <p>;=====================================================================</p> <p>.386</p> <p>.MODEL flat, stdcall</p> <p>option casemap:none</p> <p></p> <p>include windows.inc ; always first</p> <p>include macros.asm ; MASM support macros</p> <p>; -----------------------------------------------------------------</p> <p>; include files that have MASM format prototypes for function calls</p> <p>; -----------------------------------------------------------------</p> <p>include masm32.inc</p> <p>include gdi32.inc</p> <p>include user32.inc</p> <p>include kernel32.inc</p> <p>; ------------------------------------------------</p> <p>; Library files that have definitions for function</p> <p>; exports and tested reliable prebuilt code.</p> <p>; ------------------------------------------------</p> <p>includelib masm32.lib</p> <p>includelib gdi32.lib</p> <p>includelib user32.lib</p> <p>includelib kernel32.lib</p> <p></p> <p>;costants</p> <p>CR EQU 0Dh</p> <p>LF EQU 0Ah</p> <p>TABLEWIDTH EQU 10</p> <p>HBAR EQU 196</p> <p>VBAR EQU 179</p> <p>ULCORNER EQU 218</p> <p>URCORNER EQU 191</p> <p>MLBORDER EQU 195</p> <p>MRBORDER EQU 180</p> <p>LLCORNER EQU 192</p> <p>LRCORNER EQU 217</p> <p></p> <p>.Data</p> <p>menuSelection BYTE 0</p> <p>menustring BYTE &quot;Menu|I - Display program instructions|N - The user is to enter an integer number from 0 to 20|Display the first N Fibonacci numbers on the console|Quit the program&quot;</p> <p>menustringLen DWORD $-menustring</p> <p>menuDelimiter DWORD &quot;|&quot;</p> <p>IsExitSelected BYTE 0</p> <p>number BYTE 0</p> <p>.CODE</p> <p>;print a string</p> <p>;usage: push stringBuffer</p> <p>; push stringlen</p> <p>; </p> <p>;call OutputStringN</p> <p>; pop stringlen </p> <p>; pop stringBuffer </p> <p>OutputStringN PROC</p> <p>push ebp</p> <p>mov ebp , esp</p> <p>sub esp , 8 ;//2 local var</p> <p>push eax</p> <p>push ecx</p> <p>push edx</p> <p>;eax=GetStdHandle(STD_OUTPUT_HANDLE)</p> <p>invoke GetStdHandle, STD_OUTPUT_HANDLE</p> <p>mov [ebp-4] , eax ;</p> <p></p> <p>;[ebp-8]=ebp-8;</p> <p>mov eax ,ebp</p> <p>sub eax ,8</p> <p>mov [ebp-8] , eax;</p> <p>;WriteFile outputHandle, stringBuffer,stringlen,&amp;bytesWritten,0</p> <p>invoke WriteFile, [ebp-4], near ptr [ebp+12], [ebp+8], near ptr [ebp-8],0</p> <p>;cleanup</p> <p>pop edx</p> <p>pop ecx</p> <p>pop eax</p> <p>add esp , 8</p> <p>mov esp,ebp</p> <p>pop ebp</p> <p>ret</p> <p>OutputStringN ENDP</p> <p>;print a char for count times.</p> <p>;usage: push char </p> <p>; push count</p> <p>; call OutputCharN</p> <p>; pop count </p> <p>; pop char </p> <p>OutputCharN PROC</p> <p>push ebp</p> <p>mov ebp , esp</p> <p>push eax</p> <p>push ecx</p> <p>push edi</p> <p>mov ecx,[ebp+8] ;ecx=count</p> <p>JCXZ OutputCharNCleanup; do nothing if count=0</p> <p></p> <p>;allocate count bytes on the stack</p> <p>;from esp-count to esp</p> <p>;and initialize to char</p> <p>;BYTE buffer[count]</p> <p>;edi=buffer;</p> <p>;push ecx;</p> <p>;while(ecx)</p> <p>;&#123;</p> <p>; edi[ecx]=char</p> <p>;&#125;</p> <p>;pop ecx</p> <p>mov al,BYTE PTR [ebp+12]</p> <p>mov edi,esp</p> <p>sub esp,ecx</p> <p></p> <p>push ecx</p> <p>OutputCharNLoop: </p> <p>dec edi</p> <p>mov [edi], al</p> <p>loop OutputCharNLoop</p> <p>pop ecx</p> <p></p> <p>;call OutputStringN(buffer,ecx)</p> <p>push edi</p> <p>push ecx</p> <p>call OutputStringN</p> <p>pop ecx</p> <p>add esp,4</p> <p></p> <p>;free count bytes on the stack </p> <p>add esp,ecx</p> <p>OutputCharNCleanup:</p> <p>pop edi</p> <p>pop ecx </p> <p>pop eax </p> <p>mov esp,ebp</p> <p>pop ebp</p> <p>ret</p> <p>OutputCharN ENDP</p> <p>;print a char </p> <p>;by calling OutputStringN with a count of 1</p> <p>;usage: push char </p> <p>; call OutputChar</p> <p>; pop char </p> <p>OutputChar PROC</p> <p>push ebp</p> <p>mov ebp , esp</p> <p>push eax</p> <p></p> <p>;DWORD dwchar;</p> <p>sub esp,4</p> <p></p> <p>mov eax,[ebp+8] ;eax=char</p> <p>mov dword ptr[ebp-8],0 ;dwchar=0</p> <p>mov byte ptr[ebp-8],al ;dwchar=char &amp; 0x000000FF</p> <p>;call OutputStringN(&amp;dwchar,1)</p> <p>mov eax,ebp</p> <p>sub eax,8</p> <p>push eax</p> <p>push 1</p> <p>call OutputStringN</p> <p>add esp,12</p> <p></p> <p>pop eax</p> <p>mov esp,ebp</p> <p>pop ebp</p> <p>ret</p> <p>OutputChar ENDP</p> <p>;draw a table line with text and delimiters</p> <p>;usage: </p> <p>;push TableWidth</p> <p>;push beginChar</p> <p>;push textbuffer</p> <p>;push textlen</p> <p>;push fillchar</p> <p>;push endChar</p> <p>;call DrawTableLine</p> <p>;pop endChar</p> <p>;pop fillchar</p> <p>;pop textlen</p> <p>;pop textbuffer</p> <p>;pop beginChar</p> <p>;pop TableWidth </p> <p>DrawTableLine PROC</p> <p>push ebp</p> <p>mov ebp , esp</p> <p>push eax</p> <p>push ebx</p> <p>push ecx</p> <p>; do nothing if TableWidth&lt;2</p> <p></p> <p>mov ecx,[ebp+28] ;ecx=TableWidth</p> <p>cmp ecx,2 </p> <p>jb DrawTableLineCleanup</p> <p></p> <p>;beginChar, the left border</p> <p>push [ebp+24]</p> <p>call OutputChar</p> <p>add esp,4</p> <p></p> <p>;the text</p> <p></p> <p>;ebx=min(TableWidth-2,textlen);</p> <p>mov ebx,[ebp+16] ;ebx=textlen</p> <p>mov eax,ebx</p> <p>add eax,2 ;eax=textlen+2</p> <p>cmp eax,ecx ;textlen+2&lt;=TableWidth?</p> <p>jbe DrawTableLinePrintText ;yes, print it</p> <p>mov ebx,ecx ;otherwise cut the string to TableWidth-2 characters</p> <p>sub ebx,2 ;ebx=TableWidth-2</p> <p>DrawTableLinePrintText:</p> <p>;if no text to print,jump to fill the whole line</p> <p>cmp ebx,0</p> <p>je DrawTableLineFillLine</p> <p>; call OutputStringN to print the text part</p> <p>push [ebp+20]</p> <p>push ebx</p> <p>call OutputStringN </p> <p>pop ebx</p> <p>add esp,4</p> <p>DrawTableLineFillLine:</p> <p>;fill the rest of table line</p> <p>;call OutputCharN(fillchar,TableWidth-2-ebx)</p> <p>mov eax, [ebp+28]</p> <p>sub eax, 2</p> <p>sub eax, ebx</p> <p>push [ebp+12]</p> <p>push eax</p> <p>call OutputCharN;</p> <p>add esp,8</p> <p></p> <p>;endChar, the right border</p> <p>push [ebp+8]</p> <p>call OutputChar</p> <p>add esp,4</p> <p>;change line</p> <p>push CR</p> <p>call OutputChar</p> <p>add esp,4</p> <p>push LF</p> <p>call OutputChar</p> <p>add esp,4</p> <p>DrawTableLineCleanup:</p> <p>pop ecx </p> <p>pop ebx </p> <p>pop eax </p> <p>mov esp,ebp</p> <p>pop ebp</p> <p>ret</p> <p>DrawTableLine ENDP</p> <p>;draw a table top line(using ASCII code)</p> <p>;usage: </p> <p>;push TableWidth</p> <p>;call DrawTableTop </p> <p>;pop TableWidth</p> <p>DrawTableTop PROC</p> <p>push ebp</p> <p>mov ebp , esp</p> <p>;call DrawTableLine(TableWidth,ULCORNER,NULL,NULL,HBAR,URCORNER)</p> <p>push [esp+8];TableWidth</p> <p>push ULCORNER</p> <p>push 0;</p> <p>push 0;</p> <p>push HBAR</p> <p>push URCORNER</p> <p>call DrawTableLine</p> <p>add esp,24</p> <p>mov esp,ebp</p> <p>pop ebp</p> <p>ret</p> <p>DrawTableTop ENDP</p> <p>;draw a table buttom line(using ASCII code)</p> <p>;usage:</p> <p>;push TableWidth</p> <p>;call DrawTableButtom </p> <p>;pop TableWidth</p> <p>DrawTableButtom PROC</p> <p>push ebp</p> <p>mov ebp , esp</p> <p>;call DrawTableLine(TableWidth,LLCORNER,NULL,NULL,HBAR,LRCORNER)</p> <p>push [esp+8];TableWidth</p> <p>push LLCORNER</p> <p>push 0;</p> <p>push 0;</p> <p>push HBAR</p> <p>push LRCORNER</p> <p>call DrawTableLine</p> <p>add esp,24</p> <p>mov esp,ebp</p> <p>pop ebp</p> <p>ret</p> <p>DrawTableButtom ENDP</p> <p>;draw a table middle line(using ASCII code)</p> <p>;usage: </p> <p>;push TableWidth</p> <p>;call DrawTableMiddleLine </p> <p>;pop TableWidth</p> <p>DrawTableMiddleLine PROC</p> <p>push ebp</p> <p>mov ebp , esp</p> <p>;call DrawTableLine(TableWidth,MLBORDER,NULL,NULL,HBAR,MRBORDER)</p> <p>push [esp+8];TableWidth</p> <p>push MLBORDER</p> <p>push 0;</p> <p>push 0;</p> <p>push HBAR</p> <p>push MRBORDER</p> <p>call DrawTableLine</p> <p>add esp,24</p> <p>mov esp,ebp</p> <p>pop ebp</p> <p>ret</p> <p>DrawTableMiddleLine ENDP</p> <p>;draw table lines and print text (using ASCII code)</p> <p>;wrap to seperate lines if the text is too long, or delimiters were found in the text</p> <p>;usage: </p> <p>;push TableWidth</p> <p>;push stringbuffer</p> <p>;push stringlen</p> <p>;push delimiter</p> <p>;call DrawTableLineWithWrap</p> <p>;pop delimiter</p> <p>;pop stringlen </p> <p>;pop stringbuffer </p> <p>;pop TableWidth</p> <p>DrawTableLineWithWrap PROC</p> <p>push ebp</p> <p>mov ebp , esp</p> <p></p> <p>push eax ; </p> <p>push ebx ; </p> <p>push ecx ; </p> <p>push edx ;</p> <p>push edi ; </p> <p>push esi ; </p> <p>mov ebx ,[ebp+8] ;delimiter</p> <p>mov ecx ,[ebp+12] ;stringlen</p> <p>mov edx ,[ebp+20] ;TableWidth</p> <p>mov esi ,[ebp+16] ;stringbuffer</p> <p></p> <p>;DWORD curlinebase=esi;</p> <p>;BOOL bTerminate=FALSE;</p> <p>;BOOL bDelimiter;</p> <p>;edi=esi;</p> <p>;</p> <p>;while(!bTerminate&amp;&amp;edi&lt;esi+ecx)</p> <p>;&#123;</p> <p>; if(edi==esi+ecx-1 /*end of buffer*/)&#123;bDelimiter=FALSE;bTerminate=TRUE;&#125;</p> <p>; else if([edi]=='')&#123;bDelimiter=TRUE;bTerminate=TRUE;&#125;</p> <p>; else if([edi]==ebx /*delimiter*/&#123;bDelimiter=TRUE;&#125;</p> <p>; else if(edi=curlinebase+TableWidth-2) /*wrap*/&#123;bDelimiter=FALSE;&#125;</p> <p>; else &#123;edi++; continue;&#125;</p> <p>; DrawTableLine(TableWidth,MLBORDER,curlinebase,bDelimiter?edi-curlinebase:edi-curlinebase+1,HBAR,MRBORDER);</p> <p>; edi++;</p> <p>; curlinebase=edi;</p> <p>;&#125;</p> <p></p> <p>mov edi ,esi</p> <p>;allocate local vars</p> <p>sub esp ,12</p> <p>;DWORD&amp; curlinebase=*(ebp-36);6 pushed registers</p> <p>;BOOL&amp; bTerminate=*(ebp-32)</p> <p>;BOOL&amp; bDelimiter=*(ebp-28)</p> <p>mov dword ptr [ebp-36],esi</p> <p>mov dword ptr [ebp-32],0</p> <p>DrawTableLineWithWrapLoop:</p> <p>;if(bTerminate==TRUE) goto DrawTableLineWithWrapCleanup</p> <p>cmp dword ptr [ebp-32],0</p> <p>jne DrawTableLineWithWrapCleanup</p> <p>;if(edi&gt;=esi+ecx) goto DrawTableLineWithWrapCleanup</p> <p>mov eax,esi</p> <p>add eax,ecx</p> <p>cmp edi,eax </p> <p>jae DrawTableLineWithWrapCleanup</p> <p></p> <p>dec eax</p> <p>;if(edi==esi+ecx-1) goto DrawTableLineWithWrapEndOfBuffer</p> <p>cmp edi,eax </p> <p>je DrawTableLineWithWrapEndOfBuffer</p> <p></p> <p>;if([edi]==0) goto DrawTableLineWithWrapNullTerminator</p> <p>cmp byte ptr [edi],0</p> <p>je DrawTableLineWithWrapNullTerminator</p> <p></p> <p>;if([edi]==ebx) goto DrawTableLineWithWrapDelimiter</p> <p>cmp byte ptr [edi],bl</p> <p>je DrawTableLineWithWrapDelimiter</p> <p></p> <p>;if(edi==curlinebase+TableWidth-2) goto DrawTableLineWithWrapLineWrap</p> <p>mov eax,[ebp-36]</p> <p>add eax,edx</p> <p>sub eax,2</p> <p>cmp edi,eax</p> <p>je DrawTableLineWithWrapLineWrap</p> <p>inc edi</p> <p>jmp DrawTableLineWithWrapLoop</p> <p>DrawTableLineWithWrapEndOfBuffer:</p> <p>;bTerminate=TRUE,bDelimiter=FALSE;</p> <p>mov dword ptr [ebp-32],1</p> <p>mov dword ptr [ebp-28],0</p> <p>jmp DrawTableLineWithWrapDrawLine</p> <p>DrawTableLineWithWrapNullTerminator:</p> <p>;bTerminate=TRUE,bDelimiter=TRUE;</p> <p>mov dword ptr [ebp-32],1</p> <p>mov dword ptr [ebp-28],1</p> <p>jmp DrawTableLineWithWrapDrawLine</p> <p>DrawTableLineWithWrapDelimiter:</p> <p>;bDelimiter=TRUE;</p> <p>mov dword ptr [ebp-28],1</p> <p>jmp DrawTableLineWithWrapDrawLine</p> <p>DrawTableLineWithWrapLineWrap:</p> <p>;bDelimiter=FALSE;</p> <p>mov dword ptr [ebp-28],0</p> <p>;jmp DrawTableLineWithWrapDrawLine</p> <p>DrawTableLineWithWrapDrawLine:</p> <p>; DrawTableLine(TableWidth,MLBORDER,curlinebase,bDelimiter?edi-curlinebase:edi-curlinebase+1,HBAR,MRBORDER);</p> <p>push edx ;TableWidth</p> <p>push MLBORDER ;beginchar</p> <p>push [ebp-36] ;stringbuffer</p> <p>;eax=bDelimiter?edi-curlinebase:edi-curlinebase+1</p> <p>mov eax,edi</p> <p>sub eax,[ebp-36]</p> <p>cmp dword ptr [ebp-28],0</p> <p>jne DrawTableLineWithWrapDrawLine2</p> <p>add eax,1</p> <p>DrawTableLineWithWrapDrawLine2: </p> <p>push eax ;bufferlen</p> <p>push HBAR ;fillchar</p> <p>push MRBORDER ;endchar</p> <p>call DrawTableLine</p> <p>add esp,24</p> <p>; edi++;</p> <p>; curlinebase=edi;</p> <p>inc edi</p> <p>mov [ebp-36],edi</p> <p>jmp DrawTableLineWithWrapLoop</p> <p>DrawTableLineWithWrapCleanup:</p> <p>add esp ,12</p> <p>pop esi</p> <p>pop edi</p> <p>pop edx</p> <p>pop ecx</p> <p>pop ebx</p> <p>pop eax</p> <p>mov esp,ebp</p> <p>pop ebp</p> <p>ret</p> <p>DrawTableLineWithWrap ENDP</p> <p> </p> <p>ShowMenu Proc</p> <p>push ebp</p> <p>mov ebp , esp</p> <p></p> <p>push TABLEWIDTH</p> <p>call DrawTableTop</p> <p>;add esp,4</p> <p></p> <p>;push TABLEWIDTH</p> <p>push OFFSET menustring</p> <p>push menustringLen</p> <p>push menuDelimiter</p> <p>call DrawTableLineWithWrap</p> <p>sub esp,12</p> <p></p> <p>;push TABLEWIDTH</p> <p>call DrawTableButtom</p> <p>add esp,4</p> <p></p> <p>mov esp,ebp</p> <p>pop ebp</p> <p>ret</p> <p>ShowMenu EndP</p> <p>;invoke WriteFile,hOutPut,lpszText,sl,ADDR bWritten,NULL</p> <p>main PROC</p> <p>int 3</p> <p></p> <p>; call ShowMenu</p> <p>;text code of OutputChar</p> <p>; push VBAR</p> <p>; call OutputChar</p> <p>; add esp,4</p> <p>;test code of DrawTableLineWithWrap </p> <p>push TABLEWIDTH</p> <p>push OFFSET menustring</p> <p>push menustringLen</p> <p>push menuDelimiter</p> <p>call DrawTableLineWithWrap</p> <p>sub esp,12</p> <p></p> <p>exit</p> <p>main ENDP</p> <p>END main</p></font><font size="2"> <p>#=====================================================================</p> <p># lab5 - build a program that displays the Fibonacci numbers for a user defined input upper bound</p> <p># Author: Sheng_Jiang</p> <p># Course: COSC 2425</p> <p># Date: 6/21/05</p> <p>#=====================================================================</p> <p>PROJECT = Lab5</p> <p>NAME = Sheng_Jiang</p> <p>Date = 6/21/05</p> <p>ROOTDRIVE = C</p> <p>VERSION = V1</p> <p>SRCS = </p> <p>$(PROJECT).asm</p> <p>makefile </p> <p>MASM32 = $(ROOTDRIVE):/masm32</p> <p>ML = $(MASM32)/bin/ml</p> <p>LINK = $(MASM32)/bin/link</p> <p>Zip = H:/mydoc/Tools/Bin/zip</p> <p>DEBUG = c:/masm32/debug/windbg</p> <p> </p> <p>MLFLAGS = /I. /I $(MASM32)include /I $(MASM32)macros /Zi /Zd /Zf /c /Fl /coff /Cp</p> <p>LINKFLAGS = /subsystem:console /libpath:$(MASM32)lib /debug </p> <p>DEBUGFLAGS = -QY -g -G -WF $(PROJECT).WEW</p> <p>all: $(PROJECT).exe</p> <p>$(PROJECT).obj: $(PROJECT).asm</p> <p>$(ML) $(MLFLAGS) $(PROJECT).asm</p> <p>$(PROJECT).exe: $(PROJECT).obj</p> <p>$(LINK) $(LINKFLAGS) $(PROJECT).obj</p> <p>clean:</p> <p>del $(PROJECT).exe *.obj *.lst *.map *.pdb *.ilk</p> <p>zip: clean</p> <p>del $(NAME)_$(PROJECT)_$(VERSION).zip</p> <p>$(Zip) $(NAME)_$(PROJECT)_$(VERSION).zip $(SRCS)</p> <p>debug: $(PROJECT).exe</p> <p>$(DEBUG) $(DEBUGFLAGS) $(PROJECT).exe</p> <p> </p></font></div></body></html>